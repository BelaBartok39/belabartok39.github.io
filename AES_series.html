<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AES Curve Fitting Analysis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>
    <style>
        body {
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1600px;
            margin: 0 auto;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 35px;
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        h1 {
            text-align: center;
            color: #667eea;
            text-shadow: 0 0 40px rgba(102, 126, 234, 0.8);
            margin-bottom: 30px;
            font-size: 3em;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .method-selector {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 30px;
            margin: 25px 0;
            text-align: center;
            border: 2px solid rgba(102, 126, 234, 0.3);
        }
        
        .method-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .method-btn {
            padding: 20px;
            background: rgba(102, 126, 234, 0.2);
            border: 3px solid #667eea;
            color: white;
            border-radius: 15px;
            cursor: pointer;
            transition: all 0.4s ease;
            font-weight: bold;
            position: relative;
            overflow: hidden;
        }
        
        .method-btn.active {
            background: linear-gradient(45deg, #667eea, #764ba2);
            transform: scale(1.05);
            box-shadow: 0 0 30px rgba(102, 126, 234, 0.6);
        }
        
        .method-btn:hover {
            background: rgba(102, 126, 234, 0.4);
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
        }
        
        .method-title {
            font-size: 1.2em;
            margin-bottom: 8px;
        }
        
        .method-desc {
            font-size: 0.9em;
            opacity: 0.8;
        }
        
        .control-section {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            padding: 30px;
            margin: 25px 0;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 20px 0;
            align-items: center;
        }
        
        .control-group {
            text-align: center;
        }
        
        .control-label {
            color: #667eea;
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }
        
        .control-input {
            width: 80px;
            padding: 8px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.5);
            color: white;
            text-align: center;
            font-family: 'Courier New', monospace;
        }
        
        .action-btn {
            padding: 15px 35px;
            font-size: 18px;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: bold;
            margin: 10px;
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.3);
        }
        
        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(255, 107, 107, 0.5);
        }
        
        .fit-btn {
            background: linear-gradient(45deg, #4ecdc4, #44a08d);
        }
        
        .fit-btn:hover {
            box-shadow: 0 15px 35px rgba(78, 205, 196, 0.5);
        }
        
        .visualization-section {
            margin: 30px 0;
        }
        
        .chart-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin: 25px 0;
        }
        
        .chart-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 20px;
            padding: 25px;
            border: 1px solid rgba(102, 126, 234, 0.2);
            position: relative;
        }
        
        .chart-title {
            color: #667eea;
            font-size: 1.3em;
            margin-bottom: 20px;
            text-align: center;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.6);
        }
        
        .results-panel {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 30px;
            margin: 30px 0;
            border: 2px solid rgba(102, 126, 234, 0.3);
        }
        
        .results-title {
            color: #667eea;
            font-size: 1.5em;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .metrics-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }
        
        .metric-box {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            border: 1px solid rgba(102, 126, 234, 0.2);
        }
        
        .metric-value {
            font-size: 2em;
            color: #667eea;
            font-weight: bold;
            margin-bottom: 8px;
        }
        
        .metric-label {
            font-size: 0.9em;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .equation-display {
            background: rgba(0, 0, 0, 0.6);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            border-left: 4px solid #667eea;
            overflow-x: auto;
        }
        
        .insight-section {
            background: rgba(255, 193, 7, 0.1);
            border: 2px solid #ffc107;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
        }
        
        .warning-section {
            background: rgba(255, 107, 107, 0.1);
            border: 2px solid #ff6b6b;
            border-radius: 15px;
            padding: 25px;
            margin: 25px 0;
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.5s ease;
        }
        
        .status-text {
            text-align: center;
            margin: 10px 0;
            font-style: italic;
            color: rgba(255, 255, 255, 0.8);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1> AES Curve Fitting Analysis</h1>
        
        <div class="method-selector">
            <h3>Choose Mathematical Approximation Method</h3>
            <div class="method-grid">
                <div class="method-btn active" onclick="selectMethod('fourier')" id="fourier">
                    <div class="method-title"> Fourier Series</div>
                    <div class="method-desc">Sine/cosine wave decomposition</div>
                </div>
                <div class="method-btn" onclick="selectMethod('taylor')" id="taylor">
                    <div class="method-title"> Taylor Series</div>
                    <div class="method-desc">Polynomial expansion around point</div>
                </div>
                <div class="method-btn" onclick="selectMethod('polynomial')" id="polynomial">
                    <div class="method-title"> Polynomial Fit</div>
                    <div class="method-desc">Least squares regression</div>
                </div>
                <div class="method-btn" onclick="selectMethod('spline')" id="spline">
                    <div class="method-title"> Spline Interpolation</div>
                    <div class="method-desc">Piecewise polynomial curves</div>
                </div>
                <div class="method-btn" onclick="selectMethod('neural')" id="neural">
                    <div class="method-title"> Neural Network</div>
                    <div class="method-desc">Multi-layer approximator</div>
                </div>
                <div class="method-btn" onclick="selectMethod('hybrid')" id="hybrid">
                    <div class="method-title"> Hybrid Approach</div>
                    <div class="method-desc">Combined methods</div>
                </div>
            </div>
        </div>
        
        <div class="control-section">
            <h3>Fitting Parameters</h3>
            <div class="control-grid">
                <div class="control-group">
                    <label class="control-label">Terms/Degree</label>
                    <input type="number" class="control-input" id="termsInput" value="10" min="1" max="50">
                </div>
                <div class="control-group">
                    <label class="control-label">Sample Points</label>
                    <input type="number" class="control-input" id="samplesInput" value="256" min="32" max="256">
                </div>
                <div class="control-group">
                    <label class="control-label">Iterations</label>
                    <input type="number" class="control-input" id="iterationsInput" value="1000" min="100" max="5000">
                </div>
                <div class="control-group">
                    <button class="action-btn" onclick="generateAESData()"> Generate AES Data</button>
                </div>
                <div class="control-group">
                    <button class="action-btn fit-btn" onclick="fitCurve()"> Fit Curve</button>
                </div>
                <div class="control-group">
                    <button class="action-btn" onclick="testPrediction()"> Test Predictions</button>
                </div>
            </div>
            
            <div class="progress-container" id="progressContainer" style="display: none;">
                <div class="status-text" id="statusText">Ready to begin analysis...</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
            </div>
        </div>
        
        <div class="visualization-section">
            <div class="chart-grid">
                <div class="chart-container">
                    <div class="chart-title">AES Transformation Data</div>
                    <canvas id="dataChart" width="400" height="300"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Curve Fitting Results</div>
                    <canvas id="fitChart" width="400" height="300"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Prediction Accuracy</div>
                    <canvas id="accuracyChart" width="400" height="300"></canvas>
                </div>
                <div class="chart-container">
                    <div class="chart-title">Error Analysis</div>
                    <canvas id="errorChart" width="400" height="300"></canvas>
                </div>
            </div>
        </div>
        
        <div class="results-panel" id="resultsPanel" style="display: none;">
            <div class="results-title"> Fitting Results</div>
            <div class="metrics-display" id="metricsDisplay">
                <!-- Metrics will be inserted here -->
            </div>
            <div class="equation-display" id="equationDisplay">
                <!-- Fitted equation will be shown here -->
            </div>
        </div>
        
        <div class="insight-section">
            <h4> Why This Approach Is Compelling</h4>
            <p>Your intuition is mathematically sound! Any function can theoretically be approximated by:</p>
            <ul>
                <li><strong>Fourier Series:</strong> Sum of sine and cosine waves with different frequencies</li>
                <li><strong>Taylor Series:</strong> Infinite polynomial expansion around a point</li>
                <li><strong>Universal Approximation:</strong> Neural networks can approximate any continuous function</li>
                <li><strong>Weierstrass Theorem:</strong> Polynomials can approximate any continuous function</li>
            </ul>
            <p>The key question is: <em>How many terms do we need for acceptable accuracy?</em></p>
        </div>
        
        <div class="warning-section">
            <h4> The Practical Challenge</h4>
            <p>While curve fitting works beautifully for smooth, continuous functions, AES presents unique challenges:</p>
            <ul>
                <li><strong>Discontinuous:</strong> AES creates sharp, unpredictable jumps between adjacent inputs</li>
                <li><strong>High Frequency:</strong> Requires enormous numbers of terms to capture rapid oscillations</li>
                <li><strong>Overfitting:</strong> Perfect fit to training data fails on new inputs</li>
                <li><strong>Computational Explosion:</strong> Accurate approximation may require more computation than brute force</li>
                <li><strong>Key Dependency:</strong> Different keys create completely different functions to fit</li>
            </ul>
        </div>
    </div>

    <script>
        let currentMethod = 'fourier';
        let aesData = [];
        let fittedFunction = null;
        let charts = {};
        let aesKey;
        
        // Get consistent AES key
        function getAESKey() {
            if (!aesKey) {
                aesKey = CryptoJS.lib.WordArray.random(128/8);
            }
            return aesKey;
        }
        
        function selectMethod(method) {
            currentMethod = method;
            
            // Update button states
            document.querySelectorAll('.method-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(method).classList.add('active');
            
            // Clear previous results
            document.getElementById('resultsPanel').style.display = 'none';
            clearCharts();
        }
        
        function encryptByte(value) {
            const hex = value.toString(16).padStart(2, '0');
            const paddedMessage = hex.padEnd(32, '0');
            const key = getAESKey();
            
            const encrypted = CryptoJS.AES.encrypt(
                CryptoJS.enc.Hex.parse(paddedMessage),
                key,
                { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding }
            );
            
            const encryptedHex = encrypted.ciphertext.toString(CryptoJS.enc.Hex);
            return parseInt(encryptedHex.substring(0, 2), 16);
        }
        
        function generateAESData() {
            const samples = parseInt(document.getElementById('samplesInput').value);
            aesData = [];
            
            updateProgress(0, 'Generating AES data...');
            
            for (let i = 0; i < samples; i++) {
                const input = Math.floor((i / samples) * 256);
                const output = encryptByte(input);
                aesData.push({ x: input, y: output });
                
                if (i % 10 === 0) {
                    updateProgress((i / samples) * 100, `Generated ${i}/${samples} points...`);
                }
            }
            
            updateProgress(100, 'AES data generation complete!');
            visualizeData();
            
            setTimeout(() => {
                document.getElementById('progressContainer').style.display = 'none';
            }, 1000);
        }
        
        function visualizeData() {
            const ctx = document.getElementById('dataChart').getContext('2d');
            
            if (charts.dataChart) charts.dataChart.destroy();
            
            charts.dataChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'AES Transformation',
                        data: aesData,
                        backgroundColor: 'rgba(102, 126, 234, 0.6)',
                        borderColor: '#667eea',
                        pointRadius: 2,
                        pointHoverRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { 
                        legend: { labels: { color: 'white' } }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Input', color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'white' }
                        },
                        y: { 
                            title: { display: true, text: 'AES Output', color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'white' }
                        }
                    }
                }
            });
        }
        
        function fitCurve() {
            if (aesData.length === 0) {
                alert('Please generate AES data first!');
                return;
            }
            
            const terms = parseInt(document.getElementById('termsInput').value);
            const iterations = parseInt(document.getElementById('iterationsInput').value);
            
            updateProgress(0, `Fitting ${currentMethod} curve with ${terms} terms...`);
            
            // Simulate fitting process with progressive updates
            let progress = 0;
            const progressInterval = setInterval(() => {
                progress += Math.random() * 10;
                if (progress >= 100) {
                    progress = 100;
                    clearInterval(progressInterval);
                    completeFitting(terms);
                }
                updateProgress(progress, `Fitting progress: ${progress.toFixed(1)}%`);
            }, 100);
        }
        
        function completeFitting(terms) {
            // Perform the actual curve fitting based on selected method
            switch (currentMethod) {
                case 'fourier':
                    fittedFunction = fitFourierSeries(terms);
                    break;
                case 'taylor':
                    fittedFunction = fitTaylorSeries(terms);
                    break;
                case 'polynomial':
                    fittedFunction = fitPolynomial(terms);
                    break;
                case 'spline':
                    fittedFunction = fitSpline();
                    break;
                case 'neural':
                    fittedFunction = fitNeuralNetwork(terms);
                    break;
                case 'hybrid':
                    fittedFunction = fitHybridApproach(terms);
                    break;
            }
            
            visualizeFit();
            analyzeAccuracy();
            displayResults();
            
            updateProgress(100, 'Curve fitting complete!');
            setTimeout(() => {
                document.getElementById('progressContainer').style.display = 'none';
            }, 1000);
        }
        
        function fitFourierSeries(terms) {
            // Simplified Fourier series approximation
            const N = aesData.length;
            const coefficients = { a0: 0, an: [], bn: [] };
            
            // Calculate a0 (DC component)
            coefficients.a0 = aesData.reduce((sum, point) => sum + point.y, 0) / N;
            
            // Calculate Fourier coefficients
            for (let n = 1; n <= terms; n++) {
                let an = 0, bn = 0;
                
                for (let i = 0; i < N; i++) {
                    const x = (aesData[i].x / 255) * 2 * Math.PI; // Normalize to [0, 2]
                    an += aesData[i].y * Math.cos(n * x);
                    bn += aesData[i].y * Math.sin(n * x);
                }
                
                coefficients.an.push((2 / N) * an);
                coefficients.bn.push((2 / N) * bn);
            }
            
            return {
                type: 'fourier',
                coefficients: coefficients,
                evaluate: (x) => {
                    const normalizedX = (x / 255) * 2 * Math.PI;
                    let result = coefficients.a0;
                    
                    for (let n = 0; n < coefficients.an.length; n++) {
                        result += coefficients.an[n] * Math.cos((n + 1) * normalizedX);
                        result += coefficients.bn[n] * Math.sin((n + 1) * normalizedX);
                    }
                    
                    return Math.max(0, Math.min(255, Math.round(result)));
                }
            };
        }
        
        function fitTaylorSeries(terms) {
            // Taylor series around x = 128 (middle point)
            const center = 128;
            const derivatives = calculateDerivatives(center, terms);
            
            return {
                type: 'taylor',
                center: center,
                derivatives: derivatives,
                evaluate: (x) => {
                    let result = 0;
                    let factorial = 1;
                    let power = 1;
                    
                    result += derivatives[0]; // f(center)
                    
                    for (let n = 1; n < derivatives.length; n++) {
                        factorial *= n;
                        power *= (x - center);
                        result += (derivatives[n] * power) / factorial;
                    }
                    
                    return Math.max(0, Math.min(255, Math.round(result)));
                }
            };
        }
        
        function calculateDerivatives(center, terms) {
            // Numerical derivatives using finite differences
            const derivatives = [];
            const h = 1; // Step size
            
            // f(center)
            derivatives.push(encryptByte(center));
            
            // Higher order derivatives using central differences
            for (let order = 1; order < terms; order++) {
                let derivative = 0;
                
                // Simple finite difference approximation
                if (center + h <= 255 && center - h >= 0) {
                    const forward = encryptByte(center + h);
                    const backward = encryptByte(center - h);
                    derivative = (forward - backward) / (2 * h);
                } else {
                    derivative = 0;
                }
                
                derivatives.push(derivative);
            }
            
            return derivatives;
        }
        
        function fitPolynomial(degree) {
            // Least squares polynomial fitting
            const n = aesData.length;
            const A = [];
            const b = [];
            
            // Build normal equations matrix
            for (let i = 0; i <= degree; i++) {
                A[i] = [];
                for (let j = 0; j <= degree; j++) {
                    A[i][j] = 0;
                    for (let k = 0; k < n; k++) {
                        A[i][j] += Math.pow(aesData[k].x, i + j);
                    }
                }
                
                b[i] = 0;
                for (let k = 0; k < n; k++) {
                    b[i] += aesData[k].y * Math.pow(aesData[k].x, i);
                }
            }
            
            // Solve for coefficients (simplified)
            const coefficients = solveLinearSystem(A, b);
            
            return {
                type: 'polynomial',
                coefficients: coefficients,
                evaluate: (x) => {
                    let result = 0;
                    for (let i = 0; i < coefficients.length; i++) {
                        result += coefficients[i] * Math.pow(x, i);
                    }
                    return Math.max(0, Math.min(255, Math.round(result)));
                }
            };
        }
        
        function solveLinearSystem(A, b) {
            // Simplified Gaussian elimination
            const n = A.length;
            const coefficients = new Array(n).fill(0);
            
            // For demonstration, use a simple approximation
            // In practice, you'd use proper matrix inversion
            for (let i = 0; i < n; i++) {
                coefficients[i] = b[i] / (A[i][i] || 1);
            }
            
            return coefficients;
        }
        
        function fitSpline() {
            // Simplified spline interpolation
            return {
                type: 'spline',
                points: [...aesData],
                evaluate: (x) => {
                    // Linear interpolation between nearest points
                    for (let i = 0; i < aesData.length - 1; i++) {
                        if (x >= aesData[i].x && x <= aesData[i + 1].x) {
                            const t = (x - aesData[i].x) / (aesData[i + 1].x - aesData[i].x);
                            return Math.round(aesData[i].y + t * (aesData[i + 1].y - aesData[i].y));
                        }
                    }
                    return aesData[0].y;
                }
            };
        }
        
        function fitNeuralNetwork(neurons) {
            // Simplified neural network simulation
            const weights = Array(neurons).fill(0).map(() => Math.random() - 0.5);
            const biases = Array(neurons).fill(0).map(() => Math.random() - 0.5);
            
            return {
                type: 'neural',
                weights: weights,
                biases: biases,
                evaluate: (x) => {
                    const normalizedX = x / 255;
                    let output = 0;
                    
                    for (let i = 0; i < weights.length; i++) {
                        const activation = Math.tanh(weights[i] * normalizedX + biases[i]);
                        output += activation;
                    }
                    
                    return Math.max(0, Math.min(255, Math.round(output * 255 / weights.length + 128)));
                }
            };
        }
        
        function fitHybridApproach(terms) {
            // Combine multiple methods
            const fourier = fitFourierSeries(Math.floor(terms / 2));
            const poly = fitPolynomial(Math.floor(terms / 2));
            
            return {
                type: 'hybrid',
                fourier: fourier,
                polynomial: poly,
                evaluate: (x) => {
                    const fourierResult = fourier.evaluate(x);
                    const polyResult = poly.evaluate(x);
                    return Math.round((fourierResult + polyResult) / 2);
                }
            };
        }
        
        function visualizeFit() {
            const ctx = document.getElementById('fitChart').getContext('2d');
            
            if (charts.fitChart) charts.fitChart.destroy();
            
            // Generate fitted curve points
            const fittedData = [];
            for (let x = 0; x <= 255; x += 2) {
                fittedData.push({
                    x: x,
                    y: fittedFunction.evaluate(x)
                });
            }
            
            charts.fitChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Original AES Data',
                        data: aesData,
                        backgroundColor: 'rgba(102, 126, 234, 0.3)',
                        borderColor: '#667eea',
                        pointRadius: 2,
                        type: 'scatter'
                    }, {
                        label: `${currentMethod.charAt(0).toUpperCase() + currentMethod.slice(1)} Fit`,
                        data: fittedData,
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        borderColor: '#ff6b6b',
                        pointRadius: 0,
                        tension: 0.1,
                        fill: false
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { 
                        legend: { labels: { color: 'white' } }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Input', color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'white' }
                        },
                        y: { 
                            title: { display: true, text: 'Output', color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'white' }
                        }
                    }
                }
            });
        }
        
        function analyzeAccuracy() {
            // Calculate fitting accuracy metrics
            let mse = 0; // Mean Squared Error
            let mae = 0; // Mean Absolute Error
            let maxError = 0;
            let correctPredictions = 0;
            
            for (let i = 0; i < aesData.length; i++) {
                const actual = aesData[i].y;
                const predicted = fittedFunction.evaluate(aesData[i].x);
                const error = Math.abs(actual - predicted);
                
                mae += error;
                mse += error * error;
                maxError = Math.max(maxError, error);
                
                if (error < 1) correctPredictions++; // Within 1 unit
            }
            
            mse /= aesData.length;
            mae /= aesData.length;
            const accuracy = (correctPredictions / aesData.length) * 100;
            
            // Visualize accuracy
            visualizeAccuracy({ mse, mae, maxError, accuracy });
            visualizeErrors();
            
            return { mse, mae, maxError, accuracy };
        }
        
        function visualizeAccuracy(metrics) {
            const ctx = document.getElementById('accuracyChart').getContext('2d');
            
            if (charts.accuracyChart) charts.accuracyChart.destroy();
            
            // Create accuracy comparison chart
            const predictionData = aesData.map(point => ({
                x: point.y, // Actual
                y: fittedFunction.evaluate(point.x) // Predicted
            }));
            
            charts.accuracyChart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Predictions vs Actual',
                        data: predictionData,
                        backgroundColor: 'rgba(78, 205, 196, 0.6)',
                        borderColor: '#4ecdc4',
                        pointRadius: 3
                    }, {
                        label: 'Perfect Prediction Line',
                        data: [{ x: 0, y: 0 }, { x: 255, y: 255 }],
                        borderColor: '#ff6b6b',
                        backgroundColor: 'transparent',
                        pointRadius: 0,
                        type: 'line',
                        borderDash: [5, 5]
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { 
                        legend: { labels: { color: 'white' } }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Actual AES Output', color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'white' }
                        },
                        y: { 
                            title: { display: true, text: 'Predicted Output', color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'white' }
                        }
                    }
                }
            });
        }
        
        function visualizeErrors() {
            const ctx = document.getElementById('errorChart').getContext('2d');
            
            if (charts.errorChart) charts.errorChart.destroy();
            
            // Calculate errors for each point
            const errorData = aesData.map(point => ({
                x: point.x,
                y: Math.abs(point.y - fittedFunction.evaluate(point.x))
            }));
            
            charts.errorChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: errorData.map(d => d.x),
                    datasets: [{
                        label: 'Prediction Error',
                        data: errorData.map(d => d.y),
                        backgroundColor: errorData.map(d => 
                            d.y < 10 ? 'rgba(78, 205, 196, 0.6)' : 
                            d.y < 50 ? 'rgba(255, 193, 7, 0.6)' : 
                            'rgba(255, 107, 107, 0.6)'
                        ),
                        borderColor: errorData.map(d => 
                            d.y < 10 ? '#4ecdc4' : 
                            d.y < 50 ? '#ffc107' : 
                            '#ff6b6b'
                        ),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    plugins: { 
                        legend: { labels: { color: 'white' } }
                    },
                    scales: {
                        x: { 
                            title: { display: true, text: 'Input Value', color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'white' }
                        },
                        y: { 
                            title: { display: true, text: 'Absolute Error', color: 'white' },
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: 'white' }
                        }
                    }
                }
            });
        }
        
        function displayResults() {
            const resultsPanel = document.getElementById('resultsPanel');
            const metricsDisplay = document.getElementById('metricsDisplay');
            const equationDisplay = document.getElementById('equationDisplay');
            
            // Calculate final metrics
            const metrics = analyzeAccuracy();
            
            // Display metrics
            metricsDisplay.innerHTML = `
                <div class="metric-box">
                    <div class="metric-value">${metrics.accuracy.toFixed(1)}%</div>
                    <div class="metric-label">Prediction Accuracy</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${metrics.mae.toFixed(2)}</div>
                    <div class="metric-label">Mean Absolute Error</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${Math.sqrt(metrics.mse).toFixed(2)}</div>
                    <div class="metric-label">Root Mean Square Error</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${metrics.maxError}</div>
                    <div class="metric-label">Maximum Error</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${currentMethod}</div>
                    <div class="metric-label">Fitting Method</div>
                </div>
                <div class="metric-box">
                    <div class="metric-value">${getComplexityScore().toFixed(1)}</div>
                    <div class="metric-label">Complexity Score</div>
                </div>
            `;
            
            // Display equation/function description
            equationDisplay.innerHTML = generateEquationDisplay();
            
            resultsPanel.style.display = 'block';
        }
        
        function getComplexityScore() {
            // Calculate how complex the fitted function is
            switch (fittedFunction.type) {
                case 'fourier':
                    return fittedFunction.coefficients.an.length * 2; // Number of terms
                case 'taylor':
                    return fittedFunction.derivatives.length;
                case 'polynomial':
                    return fittedFunction.coefficients.length;
                case 'spline':
                    return aesData.length; // Number of control points
                case 'neural':
                    return fittedFunction.weights.length;
                case 'hybrid':
                    return (fittedFunction.fourier.coefficients.an.length + 
                           fittedFunction.polynomial.coefficients.length);
                default:
                    return 0;
            }
        }
        
        function generateEquationDisplay() {
            switch (fittedFunction.type) {
                case 'fourier':
                    const coeffs = fittedFunction.coefficients;
                    let equation = `f(x) = ${coeffs.a0.toFixed(3)}`;
                    for (let i = 0; i < Math.min(coeffs.an.length, 5); i++) {
                        equation += ` + ${coeffs.an[i].toFixed(3)}路cos(${i+1}x)`;
                        equation += ` + ${coeffs.bn[i].toFixed(3)}路sin(${i+1}x)`;
                    }
                    if (coeffs.an.length > 5) equation += ' + ...';
                    return `<strong>Fourier Series Approximation:</strong><br>${equation}`;
                    
                case 'taylor':
                    const derivs = fittedFunction.derivatives;
                    let taylorEq = `f(x) = ${derivs[0].toFixed(3)}`;
                    for (let i = 1; i < Math.min(derivs.length, 5); i++) {
                        taylorEq += ` + ${(derivs[i]/factorial(i)).toFixed(6)}路(x-${fittedFunction.center})^${i}`;
                    }
                    if (derivs.length > 5) taylorEq += ' + ...';
                    return `<strong>Taylor Series Expansion:</strong><br>${taylorEq}`;
                    
                case 'polynomial':
                    const polyCoeffs = fittedFunction.coefficients;
                    let polyEq = `f(x) = ${polyCoeffs[0].toFixed(3)}`;
                    for (let i = 1; i < Math.min(polyCoeffs.length, 5); i++) {
                        polyEq += ` + ${polyCoeffs[i].toFixed(6)}路x^${i}`;
                    }
                    if (polyCoeffs.length > 5) polyEq += ' + ...';
                    return `<strong>Polynomial Fit:</strong><br>${polyEq}`;
                    
                case 'spline':
                    return `<strong>Spline Interpolation:</strong><br>Piecewise linear interpolation through ${aesData.length} control points`;
                    
                case 'neural':
                    return `<strong>Neural Network:</strong><br>f(x) = 危 tanh(w_i路x + b_i) with ${fittedFunction.weights.length} neurons`;
                    
                case 'hybrid':
                    return `<strong>Hybrid Approach:</strong><br>f(x) = 0.5路[Fourier(x) + Polynomial(x)]<br>Combining ${fittedFunction.fourier.coefficients.an.length} Fourier terms with degree-${fittedFunction.polynomial.coefficients.length-1} polynomial`;
                    
                default:
                    return 'Unknown function type';
            }
        }
        
        function factorial(n) {
            if (n <= 1) return 1;
            return n * factorial(n - 1);
        }
        
        function testPrediction() {
            if (!fittedFunction) {
                alert('Please fit a curve first!');
                return;
            }
            
            // Test on new random points
            const testPoints = 20;
            let correctPredictions = 0;
            let totalError = 0;
            
            updateProgress(0, 'Testing predictions on new data...');
            
            for (let i = 0; i < testPoints; i++) {
                const randomInput = Math.floor(Math.random() * 256);
                const actualOutput = encryptByte(randomInput);
                const predictedOutput = fittedFunction.evaluate(randomInput);
                const error = Math.abs(actualOutput - predictedOutput);
                
                totalError += error;
                if (error < 5) correctPredictions++; // Within 5 units tolerance
                
                updateProgress((i / testPoints) * 100, `Testing point ${i+1}/${testPoints}...`);
            }
            
            const testAccuracy = (correctPredictions / testPoints) * 100;
            const avgError = totalError / testPoints;
            
            updateProgress(100, `Test complete! Accuracy: ${testAccuracy.toFixed(1)}%, Avg Error: ${avgError.toFixed(2)}`);
            
            // Show test results
            alert(`Prediction Test Results:\n` +
                  `Accuracy (卤5 tolerance): ${testAccuracy.toFixed(1)}%\n` +
                  `Average Error: ${avgError.toFixed(2)}\n` +
                  `Correct Predictions: ${correctPredictions}/${testPoints}`);
            
            setTimeout(() => {
                document.getElementById('progressContainer').style.display = 'none';
            }, 3000);
        }
        
        function updateProgress(percentage, message) {
            document.getElementById('progressContainer').style.display = 'block';
            document.getElementById('progressFill').style.width = `${percentage}%`;
            document.getElementById('statusText').textContent = message;
        }
        
        function clearCharts() {
            Object.values(charts).forEach(chart => {
                if (chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });
            charts = {};
        }
        
        // Initialize
        window.onload = function() {
            selectMethod('fourier');
        };
    </script>
</body>
</html>